
% VIM Quick Reference Card
% Copyright (c) 2009 Michael Goerz.
% TeX Format

% compile as 'pdftex vimqrc.tex'

\pdfoutput=1
\pdfpageheight=21cm
\pdfpagewidth=29.7cm

% Font definitions
\font\bigbf=cmbx12
\font\smallrm=cmr8
\font\smalltt=cmtt8
\font\tinyit=cmmi5

\def\title#1{\hfil{\bf #1}\hfil\par\vskip 2pt\hrule}
\def\cm#1#2{{\tt#1}\dotfill#2\par}
\def\cn#1{\hfill$\lfloor$ #1\par}
\def\section#1{\vskip 0.7cm {\it#1\/}\par}

% Characters definitions
\def\\{\hfil\break}
\def\bs{$\backslash$}
\def\backspace{$\leftarrow$}
\def\ctrl{{\rm\char94}\kern-1pt}
\def\enter{$\hookleftarrow$}
\def\or{\thinspace{\tinyit{or}}\thinspace}
\def\key#1{$\langle${\rm{\it#1\/}}$\rangle$}
\def\rapos{\char125}
\def\lapos{\char123}
\def\bs{\char92}
\def\tild{\char126}
\def\lbracket{[}
\def\rbracket{]}

% Three columns definitions
\parindent 0pt
\nopagenumbers
\hoffset=-1.56cm
\voffset=-1.54cm
\newdimen\fullhsize
\fullhsize=27.9cm
\hsize=8.5cm
\vsize=19cm
\def\fullline{\hbox to\fullhsize}
\let\lr=L
\newbox\leftcolumn
\newbox\midcolumn
\output={
  \if L\lr
    \global\setbox\leftcolumn=\columnbox
    \global\let\lr=M
  \else\if M\lr
    \global\setbox\midcolumn=\columnbox
    \global\let\lr=R
  \else
    \tripleformat
    \global\let\lr=L
  \fi\fi
  \ifnum\outputpenalty>-20000
  \else
    \dosupereject
  \fi}
\def\tripleformat{
  \shipout\vbox{\fullline{\box\leftcolumn\hfil\box\midcolumn\hfil\columnbox}}
  \advancepageno}
\def\columnbox{\leftline{\pagebody}}

% Card content
% Header
%\hrule\vskip 3pt
\title{VIM QUICK REFERENCE CARD}

\vskip 0.5cm
\cm{:viusage }{Show a summary of all commands }

\section{Movements}
\cm{h l k j }{character left, right; line up, down }
\cm{b w }{word/token left, right }
\cm{ge e }{end of word/token left, right}
\cm{\lapos\ \rapos }{beginning of previous, next paragraph}
\cm{( ) }{beginning of previous, next sentence}
\cm{0 \^\ \$ }{beginning, first, last character of line}
\cm{$n$G $n$gg }{line $n$, default the last, first}
\cm{$n|$ }{column $n$ of current line}
\cm{\% }{match of next brace, bracket, comment, {\tt\#define}}
\cm{- + }{line up, down on first non-blank character}
\cm{B W }{space-separated word left, right}
\cm{gE E }{end of space-separated word left, right}
\cm{g0 gm }{beginning, middle of {\it screen\/} line}
\cm{g\^\ g\$ }{first, last character of {\it screen\/} line}
\cm{f$c$ F$c$ }{next, previous occurence of character $c$}
\cm{t$c$ T$c$ }{before next, previous occurence of $c$}

\section{Jumps}
\cm{:jumps }{print the jump list}
\cm{:ta \ctrl[ }{jump to tag (under cursor)}
\cm{\ctrl O \ctrl I }{jump to older/newer location btw. buffers}
\cm{$n$g; $n$g, }{go to or edit $n$ older/newer position in change list}
\cm{'. }{jump back on last edited line}
\cm{'' }{toggle back/forward to previous/next position}

\section{Insertion \& Replace $\to$ insert mode}
\cm{i a }{insert before, after cursor}
\cm{I A }{insert at beginning, end of line}
\cm{gi gI }{insert text on last edited line / first column}
\cm{o O }{open a new line below, above the current line}
\cm{r$c$ }{replace character under cursor with $c$}
\cm{gr$c$ }{like {\tt r}, but without affecting layout}
\cm{R }{replace characters starting at the cursor}
\cm{gR }{like {\tt R}, but without affecting layout}
\cm{s$c$}{substitute char. $c$ under cursor}
\cm{c$m$ }{change text of movement command $m$}
\cm{cc\or S }{change current line}
\cm{C }{change to the end of line}

\section{Deletion}
\cm{x X }{delete character under, before cursor}
\cm{d$m$ }{delete text of movement command $m$}
\cm{dd D }{delete current line, to the end of line}
\cm{dgn }{delete the next search pattern match}
\cm{J gJ }{join current line with next, without space}
\cm{:$r$d } {delete range $r$ lines}
\cm{:$r$d$x$ } {delete range $r$ lines into register $x$}

\section{Insert/ Command Mode}
\cm{\ctrl V$c$ \ctrl V$n$ }{insert char $c$ literally, decimal value $n$}
\cm{\ctrl V$n$ }{insert decimal value of character}
\cm{\ctrl A }{insert previously inserted text}
\cm{\ctrl @ }{same as {\tt\ctrl A} and stop insert $\to$ command mode}
\cm{\ctrl R$x$ \ctrl R\ctrl R$x$ }{insert content of register $x$, literally}
\cm{\ctrl R\ctrl W}{content under cursor to command mode}
\cm{\ctrl N \ctrl P }{text completion before, after cursor}
\cm{\ctrl W }{delete word before cursor}
\cm{\ctrl U }{delete to start of current line}
\cm{\ctrl D \ctrl T }{shift left, right one shift width}
\cm{\ctrl O$c$ }{execute $c$ in temporary command mode}
\cm{\ctrl X\ctrl E \ctrl X\ctrl Y }{scroll up, down}
\cm{\key{esc}\or \ctrl\rbracket}{abandon edition $\to$ command mode}

%\vskip 0.4cm
\section{Search \& Substitution}
\cm{/$s$\enter\ ?$s$\enter }{search forward, backward for $s$}
\cm{/$s$/$o$\enter\ ?$s$?$o$\enter }{search fwd, bwd for $s$ with offset $o$}
\cm{n\or /\enter }{repeat forward last search}
\cm{N\or ?\enter }{repeat backward last search}
\cm{\# * }{search backward, forward for word under cursor}
\cm{g\# g* }{same, but also find partial matches}
\cm{gd gD }{local, global definition of symbol under cursor}
\cm{:$r$s/$f$/$t$/$x$ } {substitute $f$ by $t$ in range $r$}
\cn{$x:$ {\tt g}---all occurrences, {\tt c}---confirm changes}
\cm{:$r$s $x$ } {repeat substitution with new $r$ \& $x$}
\cm{:$r$g/$p$/$c$ :$r$v/$p$/$c$ } {execute {\it Ex\/} $c$ on range $r$ where $p$ matches/does not match}

\vskip -0.2cm
\section{Misc Ex Commands (\enter)}
\cm{:help holy-grail }{show all Ex commands}
\cm{:e $f$ }{edit file $f$, reload current file if no $f$}
\cm{:$r$w $f$ }{write range $r$ to file $f$ (current file if no $f$)}
\cm{:$r$w$>$\kern-3pt$>$$f$ }{append range $r$ to file $f$}
\cm{:q :q! }{quit and confirm, quit and discard changes}
\cm{:wq\or :x\or ZZ }{write to current file and exit}
\cm{:r $f$ }{insert content of file $f$ below cursor}
\cm{:r!\ $c$ }{insert output of command $c$ below cursor}
\cm{:$r$c\ $a$ :$r$m\ $a$ }{copy, move range $r$ below line $a$}
\cm{:$r$g/$p$/-1j }{join all lines in $r$ containing pattern $p$ with prev. line}
\cm{:$r$g/$p$/s/$q$/$y$/g }{for every line in $r$ containing $p$, substitute $q$ with $y$}
\cm{:$r$'$a$,'$b$g/$p$/j}{join any line containing the string $p$ to its subsequent line, if it lies between the $a$ and $b$ marks}



\vskip -0.2cm
\section{Ex Ranges}
\cm{, ;\ }{separates two lines numbers, set to first line }
\cm{$n$ }{an absolute line number $n$}
\cm{.\thinspace\thinspace\thinspace\$ }{the current line, the last line in file}
\cm{\% * }{entire file, visual area}
\cm{'$t$ }{position of mark $t$}
\cm{/$p$/ ?$p$? }{the next, previous line where $p$ matches}
\cm{+$n$ -$n$ }{$+n$, $-n$ to the preceding line number}



%\vskip 0.4cm
\section{Standard Mode Formatting/ Filtering}
Leave out $m$ for visual mode commands \\
\cm{gq$m$ gqgq }{format movement $m$/current paragraph}
\cm{:$r$ce $w$ } {center lines in range $r$ to width $w$}
\cm{:$r$le $i$ } {left align lines in range $r$ with indent $i$}
\cm{:$r$ri $w$ } {right align lines in range $r$ to width $w$}
\cm{!$m$$c$\enter }{filter lines of movement $m$ through command $c$}
\cm{$n$!!$c$\enter }{filter $n$ lines through command $c$}
\cm{:$r$!$c$ } {filter range $r$ lines through command $c$}
\cm{\tild }{switch case and advance cursor}
\cm{g\tild{$m$} gu$m$ gU$m$ }{switch case, lc, uc on movement $m$}
\cm{$<$$m$ $>$$m$ }{shift left, right text of movement $m$}
\cm{$n$$<$\kern-3pt$<$ $n$$>$\kern-3pt$>$ }{shift $n$ lines left, right}
\cm{\ctrl A \ctrl X}{increment/decrement number under cursor}

%\vskip 0.8cm
\section{Visual Mode}
\section{:h object-select}{Object selecting patterns}
\cm{v V \ctrl V }{start/stop highlighting characters, lines, block}
\cm{o }{exchange cursor position with start of highlighting}
\cm{gv }{start highlighting on previous visual area}
\cm{aw as ap }{select a word, a sentence, a paragraph}
\cm{ab aB }{select a block ( ), a block {\tt\lapos} {\tt\rapos}}
\cm{$n\hskip -0.3em>$ $n\hskip -0.3em<$ $=$ }{indent/unindent $n$ levels, reindent}

\section{Undoing, Repeating \& Registers}
\cm{u U }{undo last command, restore last changed line}
\cm{.\thinspace\thinspace\ctrl R }{repeat last changes, redo last undo}
\cm{$n$.\ }{repeat last changes with count replaced by $n$ }
\cm{q$c$ q$C$ }{record, append typed characters in register $c$}
\cm{q }{stop recording}
\cm{@$c$ }{execute the content of register $c$}
\cm{@@ }{repeat previous {\tt @} command}
\cm{:@$c$ } {execute register $c$ as an {\it Ex\/} command}


\section{Copying}
\cm{"$x$ }{use register $x$ for next delete, yank, put}
\cm{:reg } {show the content of all registers}
\cm{:reg $x$ } {show the content of registers $x$}
\cm{y$m$ }{yank the text of movement command $m$}
\cm{yy\or Y }{yank current line into register}
\cm{p P }{put register after, before cursor position}
\cm{\rbracket p \lbracket p }{like {\tt p}, {\tt P} with indent adjusted}
\cm{gp gP }{like {\tt p}, {\tt P} leaving cursor after new text}



\section{Patterns (differences to Perl)}
\cm{:help pattern } {show complete help on patterns}
\cm{\bs$<$ \bs$>$ }{start, end of word}
\cm{\bs i \bs k \bs I \bs K }{an identifier, keyword; excl. digits}
\cm{\bs f \bs p \bs F \bs P }{a file name, printable char.; excl. digits}
\cm{\bs e \bs t \bs r \bs b }{\key{esc}, \key{tab}, \key{\enter}, \key{$\gets$}}
\cm{\bs = * \bs + }{match $0..1$, $0..\infty$, $1..\infty$ of preceding atoms}
\cm{\bs$\{n,m\}$ }{match $n$ to $m$ occurrences}
\cm{\bs$\{-\}$ }{non-greedy match}
\cm{\bs$|$ }{separate two branches ($\equiv$ {\it or\/})}
\cm{\bs( \bs) }{group patterns into an atom}
\cm{\bs \& \bs{}1 }{the whole matched pattern, $1^{st}$ {\tt()} group}
\cm{\bs u \bs l }{upper, lowercase character}
\cm{\bs c \bs C }{ignore, match case on next pattern}
\cm{\bs \%x }{match hex character}
\cm{\bs @= \bs @! }{\tt (?=pattern) (?!pattern)\rm}
\cm{\bs @$<$= \bs @$<$! }{\tt (?$<$=pattern) (?$<$!pattern)\rm}
\cm{\bs @$>$ }{\tt (?$>$pattern)\rm }
\cm{\bs\_\^{} \bs\_\$ }{start-of-line/end-of-line, anywhere in pattern}
\cm{\bs\_. }{any single char, including end-of-line}
\cm{\bs zs \bs ze }{set start/end of pattern}
\cm{\bs \%\^{} \bs\%\$ }{match start/end of file}
\cm{\bs\%{}V }{match inside visual area}
\cm{\bs\tt'\rm m }{match with position of mark m}
\cm{\bs\%(\bs) }{unnamed grouping}
\cm{\bs\_$[$ $]$ }{collection with end-of-line included}
\cm{\bs\%$[$ $]$ }{sequence of optionally matched atoms}
\cm{\bs{}v }{very magic: patterns almost like perl}


\vskip -0.2cm
\section{Spell Checking}
\cm{:set spell spelllang=de\_20 } {activate spellcheck}
\cm{$]$s }{next misspelled word}
\cm{zg zG }{add good word (to internal word list)}
\cm{zug zuG}{undo the addition of a word to the dictionary}
\cm{zw zW }{mark bad word (to internal word list)}
\cm{z= }{suggest corrections}

\section{Marks, Motions, and Tags}
\cm{m$c$ }{mark current position with mark $c\in[a..Z]$}
\cm{`$c$ `$C$ }{go to mark $c$ in current, $C$ in any file}
\cm{`$0..9$ }{go to last exit position}
\cm{`\/`  `\/" }{go to position before jump, at last edit}
\cm{`[ `] }{go to start, end of previously operated text}
\cm{:marks } {print the active marks list}
\cm{$n$\ctrl O }{go to $n^{th}$ older position in jump list}
\cm{$n$\ctrl I }{go to $n^{th}$ newer position in jump list}
\cm{\ctrl ] \ctrl T }{jump to the tag under cursor, return from tag}
\cm{:ts $t$ } {list matching tags and select one for jump}
\cm{:tj $t$ } {jump to tag or select one if multiple matches}
\cm{:tags } {print tag list}

\section{Multiple Files / Buffers (\enter)}
\cm{:h buffers}{get help for buffer-management}
\cm{:tab ball }{show buffer tablist}
\cm{:buffers }{show list of buffers}
\cm{:on } {make current window one on screen}
\cm{:new :vnew } {create new empty window (vert.)}
\cm{:b$n$ }{switch to buffer $n$}
\cm{:bnext :bprev :bfirst :blast }{buffer movement}
\cm{:bd$n$ }{delete buffer $n$ (also with filename)}
\cm{:badd f.txt }{load file into new buffer}
\cm{:sb$n$ }{Split window and edit buffer $n$ from the buffer list}
\cm{:vertical$n$ :horizontal$c$ }{execute $c$ on vert./horiz. split}
\cm{:rightabove$c$ :leftbelow$c$ }{execute $c$ (eg. sb$n$) right/left above/below window}

\section{Buffer Shortcuts}
\cm{:h ctrl-w }{complete list of all buffer commands}
\cm{\ctrl \^{} }{toggle between the current and the last window}
\cm{\ctrl Wf gf }{open file under cursor in new/current window}
\cm{\ctrl Ww \ctrl W\ctrl W }{move to window below, above (wrap)}
\cm{\ctrl Wj \ctrl Wk }{move to window below, above}
\cm{\ctrl Wt \ctrl Wb }{move to top/bottom window}
\cm{\ctrl Wo \ctrl Wc }{close all other/current window(s)}
\cm{\ctrl Ws \ctrl Wv } {split window in two (vert.)}
\cm{\ctrl Wx } {swap open buffer windows }
\cm{\ctrl W$n$+ \ctrl W$n$- }{increase/decrease window size by $n$ lines}
\cm{\ctrl W$n>$ \ctrl W$n<$ }{increase/decrease window width}
\cm{\ctrl W = } {Make all windows equally high and wide}
\cm{\ctrl W $n\_$ }{set window height to $n$ (default: very high) }
\cm{\ctrl W $n|$ }{set current window width to $n$ }

\section{Tab Management}
\cm{:tabs }{list all tabs including their displayed windows}
\cm{:tabfirst }{go to first tab}
\cm{:tablast }{go to last tab}
\cm{:tabnew }{open a new empty tab page}
\cm{:tabc }{close current tab page}
\cm{:wqa :qa }{(save and) quit all tabs}
\cm{:tabo }{close all other tabs}
\cm{gt gT }{go to next/previous Tab}
\cm{$n$gt }{goto tab in position $n$ }

\section{Advanced Scrolling}
\cm{\ctrl D \ctrl U }{scroll half a page up, down}
\cm{\ctrl F \ctrl B }{scroll page up, down}
\cm{zt zz zb }{current line to top, center, bottom of win.}
\cm{zh zl }{scroll one character to the right, left}
\cm{zH zL }{scroll half a screen to the right, left}


\vskip -0.2cm
\section{Completion}
\cm{\ctrl{}X\ctrl{}L}{whole lines}
\cm{\ctrl{}X\ctrl{}N \ctrl{}X\ctrl{}I}{keywords in current file, plus included files}
\cm{\ctrl{}X\ctrl{}K \ctrl{}X\ctrl{}N}{keywords in dictionary, thesaurus}
\cm{\ctrl{}X\ctrl{}]}{tags}
\cm{\ctrl{}X\ctrl{}F}{file names}
\cm{\ctrl{}X\ctrl{}D}{definitions or macros}
\cm{\ctrl{}X\ctrl{}V}{vim command line}
\cm{\ctrl{}X\ctrl{}U}{user defined completion}
\cm{\ctrl{}X\ctrl{}O}{omni completion}

\section{Folding}
\cm{:set fdm=indent } {indent-foldmethod}
\cm{zf$m$ }{create fold of movement $m$}
\cm{:$r$fo }{create fold for range $r$}
\cm{zd zE }{delete fold at cursor, all in window}
\cm{zo zc zO zC }{open, close one fold; recursively}
\cm{[z ]z }{move to start, end of current open fold}
\cm{zj zk }{move down, up to start, end of next fold}
\cm{zm zM }{fold more, close all folds}
\cm{zr zR }{fold less, open all folds}
\cm{zn zN zi }{fold non, fold normal, invert folding}
\cm{:set foldcolumn=4 } {show foldcolumn}

\section{Compiling}
\cm{:compiler $c$ }{set/show compiler plugins}
\cm{:make } {run {\tt makeprg}, jump to first error}
\cm{:cope } {navigate errors from make}
\cm{:cn :cp } {display the next, previous error}
\cm{:cl :cf } {list all errors, read errors from file}

\section{Miscellaneous}
\cm{:sh :!$c$ } {start shell, execute command $c$ in shell}
\cm{:mks $name$ }{save session $name$}
\cm{vim -S $name$ }{reload vim-session $name$}
\cm{:mkview $[f]$ :loadview $[f]$ }{save/load configuration}
\cm{K }{run {\tt keywordprg} (manpage) on word under cursor}
\cm{\ctrl L }{redraw screen}
\cm{g\ctrl G}{show cursor column, line, and character position}
\cm{:set cuc } {show cursor column visually}
\cm{ga }{show A{\smallrm SCII} value of character under cursor}
\cm{gf }{open file which filename is under cursor}
\cm{:set ff=dos } {convert file to dos eol format}
\cm{:e ++ff=unix } {reopen file in unix eol format}
\cm{:set hlsearch } {highlight searches}
\cm{:$r$hardcopy $r$w!lp }{sending $r$ to printer (printout)}
\cm{:$r$hardcopy > file.ps }{print range to ps file}
\cm{:set list }{show listchar characters (tabs etc.)}
\cm{:set ic/noic }{(un)ignore cases in substitute-command}
%\cm{:,2s/\ze #/\=repeat(' ',32) }{indent comments ' #' to column 32}

\section{Most Common Digraphs}
\cm{:dig }{complete list of all digraphs}
\cm{\ctrl K$c_1$$c_2$\or $c_1$\kern-1pt\backspace$c_2$ }{enter digraph $\{c_1,c_2\}$}
\cm{Co }{Copyright }
\cm{Rg }{Registered Trademark }
\cm{!I }{!`: Inverteted Excl. Mark }
\cm{?I }{?`: Inverteted Quest. Mark }
\cm{Eu }{Euro Currency }
\cm{Li }{Britain Pound Currency }
\cm{14 12 34 }{1/4, 1/2, 3/4 etc.}

% Footer
\vfill \hrule\smallskip
{For further examples for how to use Exec-Commands see:
{\smalltt
http://stackoverflow.com/a/1220118}}\\\\
{\smallrm This card may be freely distributed under
the terms of the GNU general public licence ---
Copyright \copyright\ {\oldstyle 2009} by Michael Goerz.
{\smalltt http://www.physik.fu-berlin.de/\tild{goerz/}}. Based on original by
Laurent Gr\'egoire  ({\smalltt http://tnerual.eriogerg.free.fr/})
% Ending
\supereject
\if L\lr \else\null\vfill\eject\fi
\if L\lr \else\null\vfill\eject\fi
\bye

% EOF
